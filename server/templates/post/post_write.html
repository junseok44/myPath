{% extends 'base.html' %} {% load static %} {% block content %}
<h1>제작 페이지</h1>
<button onclick="showAllItems()">모든아이템</button>
{% if user.is_authenticated %}
<p>{{user.username}} 님 안녕하세요!</p>
<button>
  <a href="/user/auth/logout"> logout</a>
</button>
{% else %}
<p>anonymous</p>
<button>
  <a href="/user/auth/login"> login</a>
</button>
{% endif %}
<form onsubmit="handleSubmit(event)">
  <input type="text" placeholder="title" name="title" id="titleInput" />
  <input type="text" placeholder="설명" name="dsec" id="descInput" />
  <select id="categorySelect" name="categorySelect">
    {% for cat in categories %}
    <option value="{{cat.name}}">{{cat.name}}</option>
    {% endfor %}
  </select>
  <div class="main column-mode">
    <select id="pathSelect" class="select"></select>
    <button type="button" onclick="handleAddPath()" class="add_new-btn">
      옆에 새로운 패스 추가하기
    </button>
  </div>
  <input type="text" name="review" placeholder="후기" id="reviewInput" />
  <button type="submit">제출하기</button>
</form>

<script src="https://cdn.jsdelivr.net/npm/uuid@8.3.2/dist/umd/uuid.min.js"></script>
<script>
  function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== "") {
      const cookies = document.cookie.split(";");
      for (let i = 0; i < cookies.length; i++) {
        const cookie = cookies[i].trim();
        // Does this cookie string begin with the name we want?
        if (cookie.substring(0, name.length + 1) === name + "=") {
          cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
          break;
        }
      }
    }
    return cookieValue;
  }
  const csrftoken = getCookie("csrftoken");
</script>

<!-- <script>
  const listElement = document.querySelector(".main");
  const selectElement = document.getElementById("pathSelect");

  function updateSelectOptions() {
    selectElement.innerHTML = "";
    const listItems = listElement.querySelectorAll(".path");
    for (const listItem of listItems) {
      const pathTitle = listItem.querySelector(".path_title").value;
      const option = document.createElement("option");
      const classNames = listItem.className.split(" ");
      let id = null;
      for (const className of classNames) {
        if (className.startsWith("path_")) {
          id = className.slice(5); // Remove "step_" from the class name to get the "id"
          option.value = id;
        }
      }
      option.textContent = pathTitle;
      selectElement.appendChild(option);
    }
  }

  // Show the selected list item when an option is selected in the dropdown
  selectElement.addEventListener("change", () => {
    const selectedOption = selectElement.options[selectElement.selectedIndex];
    const selectedValue = selectedOption.value;
    const listItems = listElement.querySelectorAll(".path");

    // Hide all list items
    listItems.forEach((item) => (item.style.display = "none"));

    // Show the selected list item
    const selectedItem = Array.from(listItems).find((item) =>
      item.classList.contains(`path_${selectedValue}`)
    );
    if (selectedItem) {
      selectedItem.style.display = "block";
    }
  });

  if (window.innerWidth <= 600) {
    const listItems = listElement.querySelectorAll(".path");
    listItems[0].style.display = "block";
    updateSelectOptions();
  }

  // 개발용 이벤트 리스너.
  window.addEventListener("resize", () => {
    if (window.innerWidth <= 600) {
      const listItems = listElement.querySelectorAll(".path");
      listItems[0].style.display = "block";
      updateSelectOptions();
    }
  });
</script> -->

<script>
  let paths = [];
  let steps = [];
  // TODO. COLUM삭제. ORDER변경. 그리고 아이템 ORDER변경.

  const titleInput = document.querySelector("#titleInput");
  const descInput = document.querySelector("#descInput");
  const reviewInput = document.querySelector("#reviewInput");
  const categorySelect = document.querySelector("#categorySelect");

  function showAllItems() {
    console.log(steps);
  }

  function handleToggleModal(id) {
    const modal = document.querySelector(`.modal_${id}`);
    modal.classList.toggle("hidden");
    // TODO 토글시 다른 아이템들은 다 숨겨지도록 해야함.

    let titleVal = document.querySelector(`.step_${id} .title`).innerText;
    let descVal = document.querySelector(`.step_${id} .desc`).innerText;

    const titleForm = modal.querySelector(".title");
    const descForm = modal.querySelector(".desc");

    titleForm.value = titleVal;
    descForm.value = descVal;
  }

  function handleSaveValue(id) {
    const modal = document.querySelector(`.modal_${id}`);
    const titleForm = modal.querySelector(".title");
    const descForm = modal.querySelector(".desc");

    const titleNode = document.querySelector(`.step_${id} .title`);
    const descNode = document.querySelector(`.step_${id} .desc`);

    titleNode.innerText = titleForm.value;
    descNode.innerText = descForm.value;
    modal.classList.toggle("hidden");

    step = steps.find((step) => step.id == id);
    step.title = titleForm.value;
    step.desc = descForm.value;
    step.isEdited = true;
  }

  function handleChangePathTitle(e, pathId) {
    paths = paths.map((path) =>
      path.id == pathId
        ? { ...path, title: e.target.value, isEdited: true }
        : path
    );
  }

  function handleAddPath(prevPathId) {
    const NewBtn = document.querySelector(".add_new-btn");
    if (NewBtn) {
      NewBtn.parentNode.removeChild(NewBtn);
    }
    const main = document.querySelector(".main");
    let isColumnMode = main.classList.contains("column-mode");

    let id = uuid.v4();

    li = document.createElement("li");
    li.classList.add(`path`);
    li.classList.add(`path_${id}`);
    // li.innerText = `${id.slice(0, 10)}`;
    li.innerHTML += `
        <input placeholder="패스 이름 입력..." type="text" class="path_title" onchange="handleChangePathTitle(event,'${id}')">
        <button type="button" onclick="handleAddPath('${id}')">옆에 패스 추가하기</button>
        <button type="button" onclick="handleDeletePath('${id}')">이 패스 삭제하기</button>

        <div class="step_container${isColumnMode ? "" : "container_row-mode"}">
                </div>
        <button type="button" onclick="handleAddStep('${id}')" class="item_add-btn">
              밑에 아이템 추가하기
            </button>
        `;
    if (prevPathId) {
      const prevPath = document.querySelector(`.path_${prevPathId}`);
      if (prevPath.nextSibling) {
        main.insertBefore(li, prevPath.nextSibling);
      } else {
        main.append(li);
      }
    } else {
      main.append(li);
    }

    prevPath = paths.find((path) => path.id == prevPathId);
    paths.push({
      id: id,
      order: prevPath.order + 1,
      title: `${id.slice(0, 10)}`,
    });

    paths = paths.map((path) =>
      path.order >= prevPath.order + 1
        ? { ...path, order: path.order + 1 }
        : path
    );

    // path의 order에 해당하는 것들을 다 plus+1해야한다.
  }

  function handleAddStep(targetPathId) {
    let id = uuid.v4();
    const stepContainer = document.querySelector(
      `.path_${targetPathId} .step_container`
    );
    const section = document.createElement("section");
    section.classList.add(`step`);
    section.classList.add(`step_${id}`);
    section.innerHTML = `
              <div>
                <p class="title"></p>
                <p class="desc"></p>
                <button type="button" onclick="moveItemUp('${id}')">위로 올리기</button>
                <button type="button" onclick="moveItemDown('${id}')">밑으로 내리기</button>
                <button type="button" onclick="handleDeleteItem('${id}')">삭제하기</button>
                <button
                  class="edit-btn"
                  type="button"
                  onclick="handleToggleModal('${id}')"
                >
                  편집하기
                </button>
              </div>
              <div class="step__edit-modal modal_${id} hidden">
                <input type="text" class="title" />
                <textarea class="desc"></textarea>
                <div>
                  <button type="button" onClick="handleToggleModal('${id}')">취소</button>
                  <button type="button" onclick="handleSaveValue('${id}')">변경</button>
                </div>
              </div>
        `;
    stepContainer.appendChild(section);

    steps.push({
      id,
      pathId: targetPathId,
      order: steps.filter((step) => step.pathId == targetPathId).length + 1,
      isNew: true,
      isEdited: false,
      title: "",
      desc: "",
    });
  }

  function handleDeleteItem(targetStepId) {
    const targetNode = document.querySelector(`.step_${targetStepId}`);
    targetNode.parentNode.removeChild(targetNode);

    // TODO 삭제한 아이템의, order위에 있는것들을 다 하나씩 땡겨야 한다.

    const targetStep = steps.find((step) => step.id == targetStepId);

    steps = steps.map((step) => {
      if (step.colId == targetStep.colId && step.order > targetStep.order) {
        step.order -= 1;
        step.isEdited = true;
      }

      return step;
    });
    steps.splice(
      steps.findIndex((step) => step.id == targetStepId),
      1
    );
  }

  function handleDeletePath(targetPathId) {
    const main = document.querySelector(".main");
    const target = main.querySelector(`.path_${targetPathId}`);
    main.removeChild(target);

    if (main.childElementCount == 0) {
      main.innerHTML = `
      <button type="button" onclick="handleAddPath()" class="add_new-btn">
      옆에 새로운 패스 추가하기
      </button>
      `;
    }

    paths = paths.filter((path) => path.id == targetPathId);
    steps = steps.filter((step) => step.pathId !== targetPathId);
  }

  function moveItemUp(stepId) {
    const targetStep = steps.find((step) => step.id == stepId);
    const pathId = targetStep.pathId;
    const target = document.querySelector(`.step_${stepId}`);
    const container = document.querySelector(`.path_${pathId} .step_container`);
    const previousNode = target.previousSibling;
    if (!target.previousSibling) return;

    container.removeChild(target);
    container.insertBefore(target, previousNode);

    const movedStep = steps.find(
      (step) => step.pathId == pathId && step.order == targetStep.order - 1
    );

    // targetStep은 order를 -1 . movedStep은 order를 1.
    steps = steps.map((step) => {
      if (step.id == movedStep.id) return { ...step, order: step.order + 1 };
      else if (step.id === targetStep.id)
        return { ...step, order: step.order - 1 };
      else return step;
    });
  }

  function moveItemDown(stepId) {
    const targetStep = steps.find((step) => step.id == stepId);
    const pathId = targetStep.pathId;
    const target = document.querySelector(`.step_${stepId}`);
    const container = document.querySelector(`.path_${pathId} .step_container`);
    const nextNode = target.nextSibling;
    if (!nextNode) return;
    const next_nextNode = nextNode.nextSibling;

    container.removeChild(target);

    if (next_nextNode) {
      container.insertBefore(target, next_nextNode);
    } else {
      container.appendChild(target);
    }

    const movedStep = steps.find(
      (step) => step.pathId == pathId && step.order == targetStep.order + 1
    );

    steps = steps.map((step) => {
      if (step.id == movedStep.id) return { ...step, order: step.order - 1 };
      else if (step.id === targetStep.id)
        return { ...step, order: step.order + 1 };
      else return step;
    });
  }

  async function handleSubmit(e) {
    e.preventDefault();

    const response = await fetch("/post/write", {
      method: "POST",
      body: JSON.stringify({
        paths: paths,
        steps: steps,
        title: titleInput.value,
        desc: descInput.value,
        review: reviewInput.value,
        category: categorySelect.value,
        mode: "col",
      }),
      headers: {
        "content-type": "application/json",
        "X-CSRFToken": csrftoken,
      },
    });

    console.log(await response.json());

    window.location.href = "/post/list";
  }
</script>

{% endblock %}
